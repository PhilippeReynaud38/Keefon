VIVAYA / KEEFORN â€“ RÃ‰SUMÃ‰ DU SYSTÃˆME DE PAIEMENT (MODE ABSTRACTION)

Objectif gÃ©nÃ©ral
----------------
Le projet ne parle plus directement Ã  Stripe dans les pages React.
Ã€ la place, tout passe par une couche dâ€™abstraction unique : `lib/payments.ts`.

Cette couche pourra plus tard Ãªtre branchÃ©e :
- soit sur Stripe,
- soit sur un autre PSP,
- soit sur un mode â€œDEV / FAKEâ€ (celui qui est utilisÃ© actuellement).

Ainsi, on peut continuer Ã  dÃ©velopper tout le front (abonnements, boutique, crÃ©dits)
sans dÃ©pendre dâ€™un vrai compte Stripe, ni des clÃ©s secrÃ¨tes.

Fichiers principaux impliquÃ©s
-----------------------------
1) `lib/payments.ts`
   - CÅ“ur du systÃ¨me.
   - Expose une fonction :

       `export function getPaymentProvider(): PaymentProvider`

   - Le `PaymentProvider` est une interface TypeScript qui dÃ©finit au minimum :
       â€¢ `subscribeToPlan({ userId, planId })`
       â€¢ `purchaseCredits({ userId, type, quantity })`

   - Types principaux :
       â€¢ `PlanId` : `'free' | 'essential' | 'elite'` (aujourdâ€™hui)
       â€¢ `CreditType` : `'heart' | 'echo'`
       â€¢ `PaymentResult` : `{ success: boolean; message?: string }`

   - ImplÃ©mentation actuelle : un â€œDEV providerâ€ interne qui :
       â€¢ NE dÃ©clenche aucun paiement rÃ©el,
       â€¢ renvoie simplement `{ success: true, message: "...mode test..." }`,
       â€¢ peut Ã©ventuellement appeler plus tard une RPC ou une table interne
         pour stocker les changements dâ€™abonnement / de crÃ©dits.

   - Plus tard, on pourra ajouter un vrai provider Stripe du style :
       â€¢ `StripePaymentProvider` qui implÃ©mente la mÃªme interface et
         qui crÃ©era des sessions de paiement, gÃ©rera les webhooks, etc.
       â€¢ Le front nâ€™aura pas besoin de changer : il appellera toujours
         `getPaymentProvider()`.

2) `pages/abonnement.tsx`
   - Page des abonnements (Gratuit / Essentiel / Keefon+).
   - Lit le plan effectif via la vue SQL : `user_plans_effective_v`.
   - Nâ€™APPELLE PAS Stripe directement.
   - Pour changer dâ€™abonnement (boutons â€œPasser Ã  Essentielâ€ / â€œChoisir Keefon+â€),
     elle appelle :

       ```ts
       const payment = getPaymentProvider()
       const result = await payment.subscribeToPlan({
         userId,
         planId: target, // 'essential' ou 'elite'
       })
       ```

   - Si `result.success === true`, la page recharge le plan effectif Ã  partir
     de la vue Supabase, et affiche Ã©ventuellement `result.message`.
   - En mode actuel, câ€™est donc un changement â€œlogiqueâ€/interne, sans paiement rÃ©el.
   - Les boutons de navigation haut de page :
       â€¢ `â† Retour` (jaune)
       â€¢ `Tableau de bord â†’` (vert / paleGreen)
     ne sont pas liÃ©s au paiement, mais font partie de lâ€™UX autour de lâ€™abonnement.

3) `pages/boutique.tsx`
   - Nouvelle page â€œBoutique Vivayaâ€.
   - Accessible depuis le dashboard (menu â€œğŸ§ Mon espaceâ€ â†’ â€œğŸ›ï¸ Boutiqueâ€)
     et via les boutons en haut de la boutique :
       â€¢ â€œGÃ©rer mon abonnementâ€ (jaune) â†’ `/abonnement`
       â€¢ â€œTableau de bord â†’â€ (vert) â†’ `/dashboard`
   - Propose trois familles de produits :
       â€¢ Packs de cÅ“urs (hearts)
       â€¢ Packs dâ€™Ã©chos (echos)
       â€¢ Packs mixtes (bundles : cÅ“ur + Ã©cho)
   - Les produits sont dÃ©finis dans une constante `PRODUCTS` avec :
       â€¢ `id`, `label`, `description`
       â€¢ `category` : `'hearts' | 'echos' | 'bundle'`
       â€¢ `hearts`, `echos` : quantitÃ©s
       â€¢ `price` : prix affichÃ© (mode test)

   - Quand lâ€™utilisateur clique sur â€œAjouter ce packâ€, la page :
       â€¢ vÃ©rifie quâ€™il est connectÃ© via `supabase.auth.getUser()`,
       â€¢ appelle `getPaymentProvider()`,
       â€¢ envoie un ou deux appels Ã  `purchaseCredits` selon le type de pack.

     Exemples :
       - Pack cÅ“urs seuls :
         payment.purchaseCredits({ userId, type: 'heart', quantity: hearts })

       - Pack Ã©chos seuls :
         payment.purchaseCredits({ userId, type: 'echo', quantity: echos })

       - Pack mixte (bundle) : deux appels successifs
         pour cÅ“urs puis Ã©chos.

   - Les boutons â€œAjouter ce packâ€ sont dÃ©sormais tous en vert (bg-paleGreen),
     avec un Ã©tat â€œAjout en coursâ€¦â€ quand une requÃªte est en cours.

   - Le texte rappelle clairement : â€œMode test : aucun paiement rÃ©el nâ€™est effectuÃ©â€.

4) `pages/dashboard.tsx`
   - Tableau de bord principal de lâ€™utilisateur.
   - Menu â€œğŸ§ Mon espaceâ€ contient maintenant les entrÃ©es :
       â€¢ ğŸ‘¤ Mon profil  â†’ `/profile`
       â€¢ â­ Abonnement  â†’ `/abonnement`
       â€¢ ğŸ›ï¸ Boutique    â†’ `/boutique`
       â€¢ âš™ï¸ ParamÃ¨tres  â†’ `/parametres`
       â€¢ ğŸšª DÃ©connexion â†’ `/logout`
   - Le dashboard lui-mÃªme ne fait AUCUN appel au systÃ¨me de paiement,
     mais câ€™est le point dâ€™entrÃ©e UX vers lâ€™abonnement et la boutique.

Ce qui a Ã©tÃ© nettoyÃ© par rapport Ã  lâ€™ancien Stripe
--------------------------------------------------
- Les fichiers API spÃ©cifiques Stripe (create.ts, portal.ts, trial.ts, etc.)
  ne sont plus utilisÃ©s dans le front. Ils pourront Ãªtre supprimÃ©s ou rÃ©Ã©crits
  plus tard derriÃ¨re lâ€™abstraction si on rebranche Stripe.
- Les pages React ne contiennent plus de clÃ© publique Stripe, ni dâ€™appel direct
  Ã  `stripe.redirectToCheckout`, ni dâ€™URL `/api/stripe/*`.
- Toute la logique de â€œchangement de planâ€ et â€œachat de crÃ©ditsâ€ est centralisÃ©e
  dans `lib/payments.ts` en passant par `getPaymentProvider()`.

Flux gÃ©nÃ©ral (aujourdâ€™hui, en mode test)
----------------------------------------
1) Lâ€™utilisateur se connecte puis va :
   - soit sur `/abonnement` pour gÃ©rer Essentiel / Keefon+,
   - soit sur `/boutique` pour ajouter des cÅ“urs et des Ã©chos.

2) La page rÃ©cupÃ¨re `userId` via Supabase :
   - `const { data } = await supabase.auth.getUser()`.

3) La page appelle lâ€™abstraction :
   - `const payment = getPaymentProvider()`.

4) La page appelle ensuite :
   - `payment.subscribeToPlan({ userId, planId })` pour les abonnements,
   - `payment.purchaseCredits({ userId, type, quantity })` pour les crÃ©dits.

5) Le provider actuel renvoie un rÃ©sultat de test et, si nÃ©cessaire, on met Ã  jour :
   - le plan effectif via la vue `user_plans_effective_v` (pour affichage),
   - ou des compteurs internes (Ã  implÃ©menter plus tard cÃ´tÃ© BDD).

6) Aucun dÃ©bit rÃ©el, aucune redirection vers une page de paiement.

IdÃ©e pour la suite (quand on activera un vrai PSP)
--------------------------------------------------
- ImplÃ©menter un provider rÃ©el, par exemple `StripePaymentProvider`, qui :
   â€¢ traduit `subscribeToPlan` en crÃ©ation de session de paiement / abonnement,
   â€¢ traduit `purchaseCredits` en session de paiement â€œone shotâ€,
   â€¢ gÃ¨re les retours / webhooks cÃ´tÃ© backend (crÃ©dits, plan actif, etc.).

- Modifier `getPaymentProvider()` pour quâ€™il renvoie :
   â€¢ le provider DEV sur lâ€™environnement de dÃ©veloppement,
   â€¢ le provider Stripe sur lâ€™environnement de production.

- Garder strictement le mÃªme contrat :
   â€¢ les pages nâ€™appellent JAMAIS Stripe directement,
   â€¢ elles ne connaissent que `getPaymentProvider()` et les types partagÃ©s.

Ce fichier peut servir de mÃ©mo pour la prochaine session afin de se rappeler :
- oÃ¹ se trouvent les points dâ€™entrÃ©e du paiement,
- quels fichiers modifiÃ©s sont liÃ©s Ã  ce systÃ¨me,
- et comment brancher un nouveau prestataire sans casser le front.
